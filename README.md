# Java-native-Rust
Project to call native Rust code via Java Panama API

## Requirements

- Java 22+
- Jextract

## Install Jextract
- Download (early access) version that matches your operating System from: [**here**](https://jdk.java.net/jextract/)
- Extract TAR wherever you want
- Add the `bin` directory within the extracted directory into your `PATH` variable

## Run Jextract
- Help Command
    ```shell
    jextract --help 
    ```
- Generate Binding code from Java to Rust
    ```shell
    jextract --output "../../java" -t org.example --include-function hello_world --header-class-name hello_world -l native_rust_helloworld bindings.h
    ```
> Arguments:
> - "**--output**" specify the directory to place generated files. If this option is not specified, then current directory is used
> - "**-t**" target package name for the generated classes. If this option is not specified, then unnamed package is used
> - "**--include-function**" name of function to include
> - "**--header-class-name**" name of the generated header class. If this option is not specified, then header class name is derived from the header file name. For example, class "foo_h" for header "foo.h"
> - "**-l**" specify a shared library that should be loaded by the generated header class
> - Finally, "**bindings.h**" is the header file that was generated by Rust/Cargo

**NOTE:** The library name *"native_rust_helloworld"* is defined in the [**Cargo.toml**](src/main/rust/Cargo.toml) file under the `[lib]` section

## Run Jextract on Windows Powershell

Powershell most likely will block the execution. You may deactivate these restrictions globally ([**@see here**](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy)) or run all commands with the bypass flag. (Example here on a Windows machine, where Jextract was unzipped in the `C:\Program Files\OpenJDK\jextract-22` directory)

- Help Command
  ```shell
  powershell -ExecutionPolicy Bypass -File "C:\Program Files\OpenJDK\jextract-22\bin\jextract.ps1" --help 
  ```

# Build by hand

- Generate C header files from Rust code
  ```shell
  cd src/main/rust
  ```
  ```shell
  cargo build --profile release
  ```
- Copy all generated library files from `src/main/rust/target/release` directory to the `src/main/resources/native/XXX` directory, where `XXX` is your operating system. E.g.:
  - `linux_x64` for Linux (64bit) systems
  - `win_x86` for Windows (32bit) systems
  - `win_x86_64` for Windows (64bit) systems
  - `linux_arm7` for Linux (Cortex A8 - A17) systems
  - `darwin` for macOS systems
  - ...
- Change into this directory (example: Windows 64bit)
  ```shell
  cd src/main/resources/win_x86_x64
  ```
- Generate the Java binding code, that calls the Rust code over the C header files
  ```shell
  powershell jextract --output "../../../java" -t "org.example.natives" --include-function hello_world --header-class-name hello_world_win_x86_64 -l native_rust_helloworld bindings.h
  ```
- Finally, add the

## Generate C header files from Rust code

# Build with Gradle
TODO...

## What is Project Panama/Java Foreign-Function Interface?

[**Youtube: Foreign Function & Memory API - A (Quick) Peek Under the Hood**](https://www.youtube.com/watch?v=iwmVbeiA42E)